# Chapter 7 : 보조 기억 장치
- 가장 대중적인 보조 기억 장치는 **하드 디스크** 와 **플래시 메모리** 이다.


## 7.1. 하드 디스크
- 자기적인 방식으로 데이터를 저장하는 보조 기억 장치이다.
- HDD를 자기 디스크(magnetic disk)라고도 한다.

#### HDD의 구조

![HDD 구조](https://www.teamgroupinc.com/kr/upload/product_blog_b/9ec5daf37a948ebff912dc390fdd98be-20221024094614.jpg)

- 플래터(platter) : 실질적으로 데이터가 저장되는 원판이며, 자기 물질로 덮여 있어 N극과 S극으로 데이터를 저장한다.
    - 일반적으로 N극은 0으로, S극은 1로 인코딩되어 데이터를 저장한다. 
    - 이러한 방식을 통해 자기장의 방향을 변경함으로써 데이터를 읽고 쓸 수 있다.
- 스핀들(spindle) : 플래터를 회전시키는 요소로, 회전 속도는 RPM(Revolutions Per Minute) 단위로 측정된다.
    - RPM이 15000 이라면 1분에 15000 바퀴를 회전한다.
    - 상용 제품에서는 5400 RPM, 7200 RPM, 10,000 RPM, 15,000 RPM 등이 일반적이다.
    - 높은 RPM은 더 빠른 데이터 액세스를 가능하게 하지만, 전력 소비도 높고 발열이 심하다는 단점이 있다.
- 헤드(head) : 플래터 위에서 데이터를 읽고 쓰는 바늘같은 부품이다. 
    - 하드 디스크에는 여러 개의 플래터가 있을 수 있고, 각 플래터의 양면에 하나씩, 총 2개의 헤드가 있을 수 있다.
    - 단일 헤드 디스크와 다중 헤드 디스크는 하드 디스크의 헤드 수에 따라 분류된다.
        - 단일 헤드 디스크: 하나의 헤드만 가지고 있는 디스크
        - 다중 헤드 디스크: 두 개 이상의 헤드를 가지고 있는 디스크
    - 고정 헤드 디스크와 이동 헤드 디스크는 헤드의 움직임에 따라 분류된다.
        - 고정 헤드 디스크: 헤드가 움직이지 않고 고정되어 있는 디스크
        - 이동 헤드 디스크: 헤드가 움직여서 데이터를 읽고 쓰는 디스크
- 디스크 암(disk arm) : 여러 헤드를 원하는 위치로 이동시키는 역할을 한다. 
    - 하드 디스크에 있는 모든 헤드들은 이 디스크 암에 연결되어 있어, 디스크 암의 움직임에 따라 동시에 위치가 변경된다.
- 플래터는 트랙(track)과 섹터(sector)라는 단위로 데이터를 저장한다.
    - 트랙(track) : 플래터를 여러 동심원으로 나눈 각각의 원을 트랙이라고 부른다.
    - 섹터(sector) : 트랙을 여러 부분으로 나누었을 때의 각 부분을 섹터라고 부른다.
- 실린더(cylinder) : 여러 플래터에 동일한 위치에 있는 트랙들을 연결한 논리적 단위이다.
    - 연속된 정보는 보통 한 실린더에 기록된다.
    - 이는 디스크 암의 위치를 변경하지 않고도 여러 플래터에 걸쳐 빠르게 데이터를 읽고 쓸 수 있기 때문이다.

![자세한 구조](https://camo.githubusercontent.com/0f0297c96ef9869a7e3870a146dc87f0c7b8c998a1b03cd14f3a5c58c421ca94/68747470733a2f2f7777772e70637465636867756964652e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031312f30392f3331666f726d61742e6a7067)



#### 저장된 데이터에 접근하는 방법
- 하드 디스크에 쓰인 데이터에 찾아가는 방법을 관리하는 알고리즘들을 디스크 스케줄링 알고리즘이라고 한다.
- 이 알고리즘들은 하드 디스크의 헤드가 어떻게 움직일 것인지 결정하여, 헤드의 움직임과 데이터 접근을 최적화한다.
- FCFS (First-Come, First-Served)
    - 가장 간단한 알고리즘으로, 요청이 들어온 순서대로 처리한다.
    - 이 방식은 간단하지만, 헤드의 움직임이 최적화되지 않아 비효율적일 수 있다.
- SSTF (Shortest Seek Time First)
    - 현재 헤드의 위치에서 가장 가까운 요청을 먼저 처리한다.
    - 이 방식은 헤드의 움직임을 줄이기 때문에 효율적이지만, 먼 곳의 요청은 계속해서 지연될 수 있다(병목 현상).
- SCAN (Elevator)
    - 헤드가 디스크의 한쪽 끝에서 다른 끝까지 움직이면서 중간에 있는 요청을 처리한다.
    - 이 방식은 모든 요청이 공평하게 처리되지만, 헤드가 끝까지 갔다가 다시 되돌아와야 하므로 일부 지연이 발생할 수 있다.
- C-SCAN (Circular SCAN)
    - SCAN과 유사하지만, 헤드가 한쪽 끝에 도달하면 바로 다른 쪽 끝으로 이동하여 같은 방향으로 요청을 처리한다.
    - 이 방식은 SCAN보다 더 공평한 처리가 가능하다.
- LOOK and C-LOOK
    - SCAN과 C-SCAN의 변형으로, 헤드가 디스크의 끝까지 가지 않고 마지막 요청까지만 간 후 되돌아온다.
    - 이렇게 하면 불필요한 헤드의 움직임을 줄일 수 있다.

#### 목표 데이터 접근에 소요되는 시간
- 하드 디스크가 저장된 데이터에 접근하는 시간은 크게 탐색 시간, 회전 지연, 전송 시간으로 나뉜다.
    - 탐색 시간(seek time) : 찾으려는 데이터가 저장된 트랙까지 헤드를 이동시키는 시간이다.
    - 회전 지연(rotational latency) : 헤드가 위치한 곳으로 플래터를 회전시키는 시간이다.
    - 전송 시간(transfer time) : 찾은 데이터를 하드 디스크에서 다른 하드웨어나 소프트웨어로 전송하는 시간이다.

#### 플래시 메모리(flash memory)

![플래시 메모리](https://i.namu.wiki/i/JvldjUXxchZgCjPlysLWSTdSPyTNfmHPk4C0AWJz1q8nKWUPoEv11clu_Rww2oLW4uhSO3DFo8CPFxjKJjRKmnu9EHrtkpzvhbh-ucQ4CaBHxpdHQZPMgWPo3I1sNnzYX7ZAAk3epNCQdkZ7IkHUQw.webp)

- 전기적으로 데이터를 읽고 쓸 수 있는 반도체 기반의 저장 장치이며, 보조 기억 장치로도 널리 사용된다.
    - USB 드라이브, SD 카드, SSD(Solid State Drive), 스마트폰의 내부 저장 공간 등 다양한 형태로 사용된다.

![NAND와 NOR](https://t1.daumcdn.net/cfile/tistory/2362BD4357BE554401)

- 크게 NAND 플래시 메모리와 NOR 플래시 메모리가 있다.
    - NAND 플래시 : NAND 게이트 구조를 사용해 메모리 셀을 구성하며, 대용량 저장 장치에 많이 사용된다.
        - NAND 플래시 메모리는 NOR 플래시에 비해 더 촘촘한 구조를 가지고 있어서 더 많은 데이터를 저장할 수 있다.
        - 셀 하나하나에 개별적으로 접근하는 대신 페이지나 블록 단위로 데이터를 다루기 때문에 더 촘촘하게 셀을 배치할 수 있다.
        - 또한 페이지 단위로 데이터를 읽고 쓰는 특성 때문에 대용량 데이터를 빠르게 읽고 쓸 수 있다.
    - NOR 플래시 : NOR 연산을 수행하는 메모리 구조로, 주로 코드 실행 등에 사용되며 랜덤 액세스가 빠르다.
        - **랜덤 액세스(Random Access)** 라는 용어는 메모리의 어떤 위치든지 직접적이고 빠르게 접근할 수 있음을 의미한다. 
        - NOR 플래시 메모리에서는 메모리 셀이 병렬로 연결되어 있어, 각각의 셀에 직접적으로 접근할 수 있다.
        - 이러한 구조는 CPU가 메모리에서 직접 명령어를 읽어 실행하는 **Execute In Place (XIP)** 에 매우 유리하다.
- 셀(cell) : 플래시 메모리에서 데이터를 저장하는 가장 작은 단위이다.
    - 셀의 구조에 따라 한 셀에 저장할 수 있는 데이터의 양이 다르다. 
    - 이 차이는 플래시 메모리의 수명, 속도, 그리고 가격에 큰 영향을 미친다.
- SLC (Single-Level Cell) : 한 셀에 1비트만 저장한다.
    - 빠른 입출력이 가능하고, 수명도 MLC와 TLC에 비해 길다.
    - 용량 대비 가격이 높다.
    - 성능이 중요한 업무용, 산업용 장치에 주로 사용된다.
- MLC (Multi-Level Cell) : 한 셀에 2비트를 저장하며, 이로 인해 네 가지 상태를 표현할 수 있다.
    - 중간 수준의 속도와 수명을 가지며, 가격도 중간 정도이다.
    - 일반적인 소비자용 제품에 많이 사용된다.
- TLC (Triple-Level Cell) : 한 셀당 3비트를 저장하며, 이로 인해 8가지 상태를 표현할 수 있다.
    - 읽기 및 쓰기 속도는 느리며, 수명이 가장 짧다.
    - 그러나 한 셀에 더 많은 데이터를 저장할 수 있어, 대용량 저장 장치를 저렴한 가격으로 제공할 수 있다.
    - 저가형 제품과 대용량 필요 시에 주로 사용된다.

#### 단위
- 셀(cell) => 페이지(page) => 블록(block) => 플레인(plane) => 다이(die) 순으로 단위가 만들어진다.
- 플래시 메모리의 가장 큰 두 가지 특징이 있다.
    - 플래시 메모리에서 읽기와 쓰기는 페이지 단위로 이루어진다.
    - 삭제는 블록 단위로 이루어진다.
- 페이지는 일반적으로 세 가지 상태를 가질 수 있다.
    - Free : 어떠한 데이터도 저장하고 있지 않아 새로운 데이터를 저장할 수 있는 상태이다.
    - Valid : 이미 유효한 데이터를 저장하고 있는 상태이며, 새 데이터 저장이 불가능하다.
    - Invalid : 쓰레기값이라 불리는 유효하지 않은 데이터를 저장하고 있는 상태이다.
- Invalid 상태가 생기는 이유
    - 페이지 단위로 쓰기가 가능하지만 삭제는 블록 단위로만 가능하다. 
    - 따라서 블록 내에서 일부 페이지만 무효화(즉, 데이터가 더 이상 유효하지 않음)되었다면, 해당 블록은 여전히 'Invalid' 상태의 페이지를 포함하게 된다.

![페이지의 상태](https://camo.githubusercontent.com/9878a7e65dc1ee6d62c0465b7009f537ba33b487b843422d7e6d234470ff80fa/68747470733a2f2f76656c6f672e76656c63646e2e636f6d2f696d616765732f696e766964616d2f706f73742f32623662333131392d633837372d346634302d623238352d3239623537346338326533312f696d6167652e706e67)

- 가비지 컬렉션(garbage collection)
    - 유효한 페이지들만 새로운 블록으로 복사한 후 기존 블록은 삭제하여 공간을 정리하는 기능이다.
    - 동작 과정
        1. 가비지 컬렉션 프로세스가 시작되면, 먼저 블록에 있는 모든 'Valid' 페이지들이 새로운 블록으로 이동한다. 
        2. 이후, 원래 블록에 남아 있는 'Invalid' 페이지들은 삭제되고, 그 블록은 'Free' 상태로 재사용할 수 있도록 된다.

![GC의 메모리 정리](https://camo.githubusercontent.com/4431b6cf64eeaced2a886f8f6b0f7e348ade3252a3c1241b8d0551d1127604e9/68747470733a2f2f76656c6f672e76656c63646e2e636f6d2f696d616765732f696e766964616d2f706f73742f38326431623539342d643166372d346265392d383933302d3666376536653661333065312f696d6167652e706e67)

## 7.2. RAID의 정의와 종류

### 7.2.1. RAID의 정의
- 하드 디스크와 SSD, 그 외의 다양한 유형의 보조 저장 장치를 사용할 수 있는 기술이다.
- 데이터의 안정성, 높은 성능, 혹은 두 가지를 모두 위해 여러 개의 물리적 보조 기억 장치를 하나의 논리적 보조 기억 장치처럼 사용하는 기술이다.

![What is RAID](https://camo.githubusercontent.com/4bb268cb14add28691ebf7d708bb57ae9a8c8f13e111508f5573e1b7623bd6cd/68747470733a2f2f69302e77702e636f6d2f697077697468656173652e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031362f31302f776861742d69732d726169642d64702e6a7067)

### 7.2.2. RAID의 종류
- 구성 방법을 RAID 레벨이라 표현한다.
- RAID 0, RAID 1, RAID 2, RAID 3, RAID 4, RAID 5, RAID 6, RAID 10, RAID 50 등이 있다.
    - RAID 10은 RAID 0과 RAID 1을 혼합, RAID 50은 RAID 0과 RAID 5을 혼합한 방식이다.
    - 여러 RAID 레벨을 혼합한 방식을 **Nested RAID** 라고 부른다.

#### RAID 0

![RAID 0](https://camo.githubusercontent.com/5007c337f9cedcf9a393d60db21ec72741cd93850def54b1ab40a8c2d9c4ea7e/68747470733a2f2f76656c6f672e76656c63646e2e636f6d2f696d616765732f696e766964616d2f706f73742f31393665313666302d343131312d343363352d623831332d6134623530633963666561352f696d6167652e706e67)

- 여러 보조 기억 장치에 데이터를 나누어 저장하는 구성 방식이다.
- 데이터가 번갈아 가며 저장되며, 이를 스트라이핑(striping)이라 한다.
- 읽고 쓰는 속도가 빨라진다.
- 하지만, 하나의 드라이브가 실패하면 모든 데이터가 손실될 수 있다.

#### RAID 1
- 두 개 이상의 디스크에 동일한 데이터를 저장하여 복사본을 만드는 방식이다.
- 데이터를 쓸 때 모든 디스크에 동시에 쓴다.
    - 쓰기 속도가 0보다 느리다.
- 하드웨어 실패의 경우 복구가 매우 간단하다.

#### RAID 4
- 1처럼 복사본을 만드는 대신 오류를 검출하고 복구하기 위한 정보를 저장하는 구성 방식이다.
- 오류를 검출하고 복구하기 위한 정보를 패리티 비트(parity bit)라 한다.
- 패리티 비트는 본래 오류 검출용 정보지만 RAID에서는 오류 복구도 가능하다.

#### RAID 5
- RAID 4 에서는 새로운 데이터가 저장될 때마다 패리티를 저장하는 디스크에도 데이터를 쓰게 되므로 패리티를 저장하는 장치에 병목이 발생한다.
- RAID 5 에서는 패리티 정보를 분산하여 저장하는 방식으로 병목을 해결한다.

#### RAID 6
- 서로 다른 두 개의 패리티를 두는 방식이다.
    - 오류를 검출하고 복구할 수 있는 수단이 두 개인 것이다.
- 새로운 정보를 저장할 때마다 저장할 패리티가 두 개이므로 쓰기 속도가 5보다 느리다.

#### 패리티 비트로 데이터를 복구하는 방법
- XOR 연산이나 [Reed-Solomon](https://en.wikipedia.org/wiki/Reed%E2%80%93Solomon_error_correction) 알고리즘과 같은 수학적 연산을 통해 가능하다.
> 예를 들어, A, B, C 세 개의 데이터 블록이 있고 P가 패리티 블록임을 가정한다.

> 1. 패리티 P는 A, B, C 블록의 각 비트를 XOR 연산하여 계산된다.
> 2. P = A XOR B XOR C
> 3. 만약 C 디스크가 실패한다면, 다음과 같은 방법으로 C 블록을 복구할 수 있다.
> 4. C = A XOR B XOR P
> 5. 이런 식으로 어느 하나의 디스크가 실패하더라도 나머지 디스크와 패리티 정보를 이용해 원래의 데이터를 복구할 수 있다.


# Chapter 8 : 입출력장치

## 8.1. 장치 컨트롤러와 장치 드라이버

### 8.1.1. 장치 컨트롤러
- 입출력 장치는 다루기 복잡하며, 종류가 다양하기 때문에 장치마다의 속도와 데이터 전송 형식 등이 다를 수 있다. 따라서 표준화하기가 어렵다.
- 일반적으로 CPU와 메모리의 데이터 전송률은 높지만, 입출력 장치의 데이터 전송률은 상대적으로 낮다.
    - 전송률(transfer rate)은 데이터를 얼마나 빨리 교환할 수 있는지를 나타내는 지표이다.
- 이러한 이유로 입출력 장치는 보통 장치 컨트롤러(device controller)라는 하드웨어를 통해 CPU나 메모리와 연결된다.
    - 입출력 제어기(I/O controller), 입출력 모듈(I/O module) 등으로도 불린다.
- 장치 컨트롤러는 다음과 같은 주요 작업을 수행한다:
    - CPU와 입출력 장치 간의 통신 중개
    - 오류 검출 및 복구
    - 데이터 버퍼링
        - 버퍼링은 데이터를 일시적으로 저장하여 전송률의 차이를 완화하는 기술이다.

![장치 컨트롤러, 장치 드라이버](https://camo.githubusercontent.com/c81947ff0af97c81df32adde12efbe74e32b80b3f83a2d79262825df4aa97b9d/68747470733a2f2f76656c6f672e76656c63646e2e636f6d2f696d616765732f696e766964616d2f706f73742f63363562326561392d613765392d346234362d623837662d3830613066393539633638382f696d6167652e706e67)

#### 장치 컨트롤러의 내부 구조
- 데이터 레지스터(data register) : CPU와 입출력 장치 사이에서 교환되는 데이터가 저장되는 레지스터이다.
    - 이 레지스터는 장치 컨트롤러 내부의 데이터 버퍼 역할을 한다.
    - 레지스터 대신, 일부 구현에서는 RAM을 사용할 수도 있다.
- 상태 레지스터(status register) : 입출력 장치의 현재 상태 정보가 저장되는 레지스터이다.
    - 작업이 준비되었는지, 작업이 완료되었는지, 오류가 발생했는지 등의 정보가 담긴다.
- 제어 레지스터(control register) : 입출력 장치가 수행할 작업과 관련된 제어 정보와 명령어가 저장되는 레지스터이다.
- 상태 레지스터와 제어 레지스터는 일부 경우에 하나의 레지스터로 병합되어 사용될 수 있다.
- 위 레지스터들에 저장된 정보는 시스템 버스를 통해 CPU나 다른 입출력 장치로 전달된다.

#### 장치 드라이버(decive driver)
- 장치 드라이버는 장치 컨트롤러의 동작을 감지하고 제어함으로써, 컴퓨터와 입출력장치 사이에서 데이터 교환을 가능하게 하는 소프트웨어 모듈이다.
- 장치 컨트롤러가 하드웨어적인 인터페이스를 제공한다면, 장치 드라이버는 소프트웨어적인 인터페이스를 제공한다.
- 장치 드라이버를 로드하고 실행하는 주체는 대개 운영체제(OS)이다.
- 운영체제에는 기본적으로 일반적인 장치 드라이버가 포함되어 있을 수 있지만, 특정 장치의 최적 활용을 위해서는 장치 제작자가 제공하는 특수한 드라이버가 필요할 수 있다.



## 8.2. 다양한 입출력 방법
- 입출력 작업을 수행하려면 CPU와 장치 컨트롤러가 정보를 주고받아야 한다.
- 정보를 주고받는 방법에는 프로그램 입출력(Programmed I/O), 인터럽트 기반 입출력(Interrupt-based I/O), 그리고 DMA(Direct Memory Access) 입출력 등이 있다.

### 8.2.1. 프로그램 입출력(programmed I/O)
- 이 방식에서 CPU는 프로그램 코드를 통해 입출력 장치를 직접 제어한다.
- 메모리에 저장된 데이터를 하드 디스크에 백업하는 과정은 다음과 같다.
    1. CPU는 하드 디스크 컨트롤러의 제어 레지스터에 쓰기 명령을 전달, 이로써 하드 디스크에 새로운 정보를 쓸 준비를 한다.
    2. 하드 디스크 컨트롤러는 하드 디스크의 상태를 확인한다. 준비가 되면 상태 레지스터에 준비되었다는 정보를 업데이트한다.
    3. CPU는 상태 레지스터를 주기적으로 읽어 하드 디스크의 준비 상태를 확인한다. 준비가 완료되면 백업할 메모리의 데이터를 데이터 레지스터에 쓴다.
    4. 작업이 끝날 때까지 1부터 3의 과정을 반복한다.
- CPU는 기본적으로 내장된 레지스터들의 상태를 알고 있지만, 여러 장치 컨트롤러의 레지스터 상태를 모두 알고 있을 수는 없다.
- CPU가 입출력을 처리하는 방법에는 메모리 맵 입출력(Memory-mapped I/O)과 고립형 입출력(Isolated I/O)이 있다.

#### 메모리 맵 입출력(memory-mapped I/O)
- 이 방법은 프로그래밍이 더 간단해지는 장점이 있다. 
    - 메모리와 입출력 장치를 동일한 명령셋으로 제어할 수 있기 때문이다.
- 하지만 메모리와 입출력 장치의 주소 공간이 겹치지 않도록 관리해야 한다.

#### 고립형 입출력(isolated I/O)
- 이 방법은 메모리와 입출력 장치를 명확히 구분하므로, 주소 공간의 충돌을 방지할 수 있는 장점이 있다.
- 하지만 입출력 장치를 제어하기 위해 별도의 입출력 명령어를 사용해야 하므로, 프로그래밍이 약간 복잡해질 수 있다.


### 8.2.2. 인터럽트 기반 입출력(interrupt driven I/O)
- 입출력장치에 의한 하드웨어 인터럽트는 입출력장치가 아닌 장치 컨트롤러에 의해 발생한다.
- CPU는 장치 컨트롤러에 입출력 작업을 명령하고, 장치 컨트롤러는 입출력장치를 제어하며 입출력을 수행한다. 
    - 이때 장치 컨트롤러가 독립적으로 입출력 작업을 수행하므로 CPU는 다른 일을 할 수 있다.
- 장치 컨트롤러가 입출력 작업을 끝낸 뒤에는 CPU에게 인터럽트 요청 신호를 보낸다. CPU는 현재 수행 중인 작업을 백업하고 인터럽트 서비스 루틴을 실행한다.
- 여러 입출력장치에서 인터럽트가 동시에 발생한 경우, 이를 처리하는 두 가지 방법이 있다. 
    - 순차적으로 처리하는 방법과, 또 하나는 우선순위가 높은 인터럽트를 먼저 처리하는 방법이다. 우선순위가 높은 인터럽트를 처리하기 위해 인터럽트 컨트롤러가 종종 사용된다.
- NMI(Non-Maskable Interrupt) : 일반적으로 중요한 시스템 오류나 예외 상황에서 발생한다. 이 인터럽트는 일반적인 인터럽트와 달리 무시하거나 비활성화할 수 없다.

#### 프로그래머블 인터럽트 컨트롤러(PIC; Programmable Interrupt Controller)
- 여러 장치 컨트롤러에 연결되어 장치 컨트롤러에서 보낸 하드웨어 인터럽트 요청들의 우선순위를 판별한 뒤 CPU에 지금 처리해야 할 하드웨어 인터럽트는 무엇인지 알려주는 장치이다.
- 그 과정은 다음과 같다.
    1. PIC가 장치 컨트롤러에서 인터럽트 요청 신호를 받아들인다.
    2. PIC는 인터럽트 우선순위를 판단한 뒤 CPU에 처리해야 할 인터럽트 요청 신호를 보낸다.
    3. CPU는 PIC에 인터럽트 확인 신호를 보낸다.
    4. PIC는 데이터 버스를 통해 CPU에 인터럽트 벡터를 보낸다.
    5. CPU는 인터럽트 벡터를 통해 인터럽트 요청의 주체를 알게 되고, 해당 장치의 인터럽트 서비스 루틴을 실행한다.
- PIC는 NMI까지 판단하지는 않는다.
    - NMI는 순위가 가장 높아 우선순위 판별이 불필요하다.


### 8.2.3. DMA 입출력
- 프로그램 기반 입출력과 인터럽트 기반 입출력에 공통점은 둘다 CPU를 거친다는 것이다.
- 이런 경우 CPU가 입출력장치를 위한 연산 때문에 성능이 저하된다.
    - 하드 디스크 백업과 같은 대용량 데이터를 옮길 때 CPU의 부담이 더욱 커진다.
- DMA(Direct Memory Access) : 입출력장치와 메모리가 CPU를 거치지 않고 상호작용할 수 있는 입출력 방식
    - 직접 메모리에 접근할 수 있는 입출력 기능이다.
    - DMA가 작동하기 위해선 시스템 버스에 연결된 DMA 컨트롤러라는 하드웨어가 필요하다.

#### DMA 입출력 과정

![DMA](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcpS4Jg%2FbtqzzJqbQoE%2FSnBvOAyaffi7ufg5CZsUbK%2Fimg.jpg)

- DMA 입출력 과정은 다음과 같다.
    1. CPU는 DMA 컨트롤러에 입출력장치의 주소, 수행할 연산, 읽거나 쓸 메모리의 주소 등과 같은 정보로 입출력 작업을 명령한다.
    2. DMA 컨트롤러는 CPU 대신 장치 컨트롤러와 상호작용하며 입출력 작업을 수행한다. 필요한 경우 메모리에 직접 접근하여 정보를 읽거나 쓴다.
    3. 입출력 작업이 끝나면 DMA 컨트롤러는 CPU에 인터럽트를 걸어 작업이 끝났음을 알린다. 이를 통해 CPU는 다른 작업에 집중할 수 있다.
- 시스템 버스 동시 사용에 대한 제한
    - 기본적으로 시스템 버스는 동시에 여러 장치에 의해 사용될 수 없다. 따라서 CPU가 시스템 버스를 사용할 때 DMA 컨트롤러는 사용할 수 없고, 반대의 경우도 마찬가지다. 
    - 하지만 고성능 시스템에서는 이 제약이 다소 완화될 수 있다.
- 사이클 스틸링(cycle stealing)
    - DMA 컨트롤러는 CPU가 시스템 버스를 사용하지 않을 때마다 시스템 버스를 이용하거나, 필요에 따라 CPU에게 버스 사용을 요청한다. 이러한 동작을 사이클 스틸링이라고 부른다.

#### 입출력 버스

![I/O Bus](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FsB1qZ%2FbtqzAjx0EJA%2FxCUt684LA4t7adA3dVth80%2Fimg.jpg)

- CPU, 메모리, DMA 컨트롤러, 장치 컨트롤러가 모두 같은 버스를 공유하는 구성에는 DMA를 위해 한 번 메모리에 접근할 때마다 시스템 버스를 두 번 사용하게 되는 부작용이 있다.
- DMA를 위해 시스템 버스를 너무 자주 사용하면 그만큼 CPU가 시스템 버스를 이용하지 못한다.
- 그래서 DMA 컨트롤러와 장치 컨트롤러들을 입출력 버스(input/output bus) 라는 별도의 버스에 연결하여 해결하였다.
- 입출력 버스에는 PCI(Peripheral Component Interconnect) 버스, PCI Express(PCle) 버스 등 여러 종류가 있다.
- 입출력 프로세서(IOP; Input/Output Processor) / 입출력 채널(Input/Output Channel)
    - 메모리에 직접 접근할 뿐만 아니라 입출력 명령어를 직접 인출하고, 해석하고, 실행까지 하는 일종의 입출력 전용 CPU 이다.
    - 입출력 채널이 있는 컴퓨터에서는 CPU가 입출력 채널에게 메모리에 저장된 특정 입출력 명령어를 수행하라고 지시하면, 입출력 채널은 그 결과를 CPU에게 반환한다.

--- 

# 참고자료
- [Disk Scheduling Algorithms](https://www.geeksforgeeks.org/disk-scheduling-algorithms/)
- [플래시 메모리(Flash memory)의 구조와 원리](https://imsosimin.com/5)
- [손상된 데이터 복구는 어떻게 하는 겁니까? // 패러티(parity), 패리티의 원리 - Youtube](https://www.youtube.com/watch?v=iODe73LMy1o)